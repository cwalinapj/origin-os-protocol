import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PublicKey, Keypair, SystemProgram } from "@solana/web3.js";
import {
  TOKEN_PROGRAM_ID,
  ASSOCIATED_TOKEN_PROGRAM_ID,
  createMint,
  getOrCreateAssociatedTokenAccount,
  mintTo,
} from "@solana/spl-token";
import { expect } from "chai";

// Import IDLs (generated by anchor build)
import { ModeRegistry } from "../target/types/mode_registry";
import { CollateralVault } from "../target/types/collateral_vault";
import { SessionEscrow } from "../target/types/session_escrow";
import { StakingRewards } from "../target/types/staking_rewards";

describe("Origin OS Protocol", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  // Programs
  const modeRegistry = anchor.workspace.ModeRegistry as Program<ModeRegistry>;
  const collateralVault = anchor.workspace.CollateralVault as Program<CollateralVault>;
  const sessionEscrow = anchor.workspace.SessionEscrow as Program<SessionEscrow>;
  const stakingRewards = anchor.workspace.StakingRewards as Program<StakingRewards>;

  // Test accounts
  const admin = Keypair.generate();
  const provider1 = Keypair.generate();
  const user1 = Keypair.generate();

  // Token mints
  let paymentMint: PublicKey;
  let positionNftMint: PublicKey;

  // Mode configuration
  const MODE_ID = 1;
  const CR_BPS = 15000; // 150%

  before(async () => {
    // Airdrop SOL to test accounts
    const airdropAdmin = await provider.connection.requestAirdrop(
      admin.publicKey,
      10 * anchor.web3.LAMPORTS_PER_SOL
    );
    await provider.connection.confirmTransaction(airdropAdmin);

    const airdropProvider = await provider.connection.requestAirdrop(
      provider1.publicKey,
      10 * anchor.web3.LAMPORTS_PER_SOL
    );
    await provider.connection.confirmTransaction(airdropProvider);

    const airdropUser = await provider.connection.requestAirdrop(
      user1.publicKey,
      10 * anchor.web3.LAMPORTS_PER_SOL
    );
    await provider.connection.confirmTransaction(airdropUser);

    // Create payment token mint
    paymentMint = await createMint(
      provider.connection,
      admin,
      admin.publicKey,
      null,
      6 // 6 decimals
    );

    // Create position NFT mint (will be used as template)
    positionNftMint = await createMint(
      provider.connection,
      admin,
      admin.publicKey,
      null,
      0 // NFT has 0 decimals
    );

    console.log("Payment Mint:", paymentMint.toBase58());
    console.log("Position NFT Mint:", positionNftMint.toBase58());
  });

  describe("Mode Registry", () => {
    it("Initializes global config", async () => {
      const [configPda] = PublicKey.findProgramAddressSync(
        [Buffer.from("config")],
        modeRegistry.programId
      );

      try {
        await modeRegistry.methods
          .initialize()
          .accounts({
            config: configPda,
            authority: admin.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .signers([admin])
          .rpc();

        const config = await modeRegistry.account.globalConfig.fetch(configPda);
        expect(config.authority.toBase58()).to.equal(admin.publicKey.toBase58());
        expect(config.modeCount).to.equal(0);
        console.log("✓ Global config initialized");
      } catch (e) {
        console.log("Config init error:", e);
        throw e;
      }
    });

    it("Registers a new mode", async () => {
      const [configPda] = PublicKey.findProgramAddressSync(
        [Buffer.from("config")],
        modeRegistry.programId
      );

      const [modePda] = PublicKey.findProgramAddressSync(
        [Buffer.from("mode"), new anchor.BN(MODE_ID).toArrayLike(Buffer, "le", 4)],
        modeRegistry.programId
      );

      await modeRegistry.methods
        .registerMode(MODE_ID, CR_BPS)
        .accounts({
          config: configPda,
          mode: modePda,
          authority: admin.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([admin])
        .rpc();

      const mode = await modeRegistry.account.modeConfig.fetch(modePda);
      expect(mode.modeId).to.equal(MODE_ID);
      expect(mode.crBps).to.equal(CR_BPS);
      expect(mode.active).to.equal(true);
      console.log("✓ Mode registered with CR:", CR_BPS, "bps");
    });

    it("Adds collateral mint to allowlist", async () => {
      const [modePda] = PublicKey.findProgramAddressSync(
        [Buffer.from("mode"), new anchor.BN(MODE_ID).toArrayLike(Buffer, "le", 4)],
        modeRegistry.programId
      );

      const [allowlistPda] = PublicKey.findProgramAddressSync(
        [Buffer.from("allow"), new anchor.BN(MODE_ID).toArrayLike(Buffer, "le", 4), paymentMint.toBuffer()],
        modeRegistry.programId
      );

      await modeRegistry.methods
        .addMint(MODE_ID)
        .accounts({
          mode: modePda,
          allowlist: allowlistPda,
          mint: paymentMint,
          authority: admin.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([admin])
        .rpc();

      const allowlist = await modeRegistry.account.mintAllowlist.fetch(allowlistPda);
      expect(allowlist.mint.toBase58()).to.equal(paymentMint.toBase58());
      expect(allowlist.allowed).to.equal(true);
      console.log("✓ Payment mint added to allowlist");
    });
  });

  describe("Collateral Vault", () => {
    let providerTokenAccount: PublicKey;
    let positionPda: PublicKey;

    before(async () => {
      // Mint tokens to provider
      const providerAta = await getOrCreateAssociatedTokenAccount(
        provider.connection,
        admin,
        paymentMint,
        provider1.publicKey
      );
      providerTokenAccount = providerAta.address;

      await mintTo(
        provider.connection,
        admin,
        paymentMint,
        providerTokenAccount,
        admin,
        1_000_000_000 // 1000 tokens
      );

      [positionPda] = PublicKey.findProgramAddressSync(
        [
          Buffer.from("pos"),
          provider1.publicKey.toBuffer(),
          new anchor.BN(MODE_ID).toArrayLike(Buffer, "le", 4),
        ],
        collateralVault.programId
      );

      console.log("Provider token balance:", 1000);
    });

    it("Provider deposits collateral", async () => {
      const depositAmount = new anchor.BN(500_000_000); // 500 tokens

      const vaultAta = await anchor.utils.token.associatedAddress({
        mint: paymentMint,
        owner: positionPda,
      });

      const providerNftAta = await anchor.utils.token.associatedAddress({
        mint: positionNftMint,
        owner: provider1.publicKey,
      });

      await collateralVault.methods
        .deposit(MODE_ID, depositAmount)
        .accounts({
          position: positionPda,
          vaultTokenAccount: vaultAta,
          providerTokenAccount: providerTokenAccount,
          collateralMint: paymentMint,
          positionNftMint: positionNftMint,
          providerNftAccount: providerNftAta,
          provider: provider1.publicKey,
          tokenProgram: TOKEN_PROGRAM_ID,
          associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
        })
        .signers([provider1])
        .rpc();

      const position = await collateralVault.account.providerPosition.fetch(positionPda);
      expect(position.total.toString()).to.equal(depositAmount.toString());
      expect(position.reserved.toString()).to.equal("0");
      console.log("✓ Collateral deposited:", 500, "tokens");
    });
  });

  describe("Session Escrow", () => {
    const SESSION_NONCE = new anchor.BN(1);
    let sessionPda: PublicKey;
    let userTokenAccount: PublicKey;

    before(async () => {
      // Mint tokens to user
      const userAta = await getOrCreateAssociatedTokenAccount(
        provider.connection,
        admin,
        paymentMint,
        user1.publicKey
      );
      userTokenAccount = userAta.address;

      await mintTo(
        provider.connection,
        admin,
        paymentMint,
        userTokenAccount,
        admin,
        100_000_000 // 100 tokens
      );

      [sessionPda] = PublicKey.findProgramAddressSync(
        [
          Buffer.from("sess"),
          user1.publicKey.toBuffer(),
          SESSION_NONCE.toArrayLike(Buffer, "le", 8),
        ],
        sessionEscrow.programId
      );

      console.log("User token balance:", 100);
    });

    it("User opens a session", async () => {
      const escrowAta = await anchor.utils.token.associatedAddress({
        mint: paymentMint,
        owner: sessionPda,
      });

      await sessionEscrow.methods
        .openSession(
          SESSION_NONCE,
          MODE_ID,
          new anchor.BN(1_000_000),    // chunk_size: 1 token
          new anchor.BN(100_000),       // price_per_chunk: 0.1 token
          new anchor.BN(50_000_000),    // max_spend: 50 tokens
          new anchor.BN(100),           // start_deadline_slots
          new anchor.BN(50)             // stall_timeout_slots
        )
        .accounts({
          session: sessionPda,
          escrowTokenAccount: escrowAta,
          paymentMint: paymentMint,
          user: user1.publicKey,
          provider: provider1.publicKey,
          tokenProgram: TOKEN_PROGRAM_ID,
          associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
        })
        .signers([user1])
        .rpc();

      const session = await sessionEscrow.account.session.fetch(sessionPda);
      expect(session.user.toBase58()).to.equal(user1.publicKey.toBase58());
      expect(session.provider.toBase58()).to.equal(provider1.publicKey.toBase58());
      expect(session.state.open).to.not.be.undefined;
      console.log("✓ Session opened");
      console.log("  Coverage P:", session.coverageP.toString());
      console.log("  Reserve R:", session.reserveR.toString());
    });

    it("User funds the session", async () => {
      const fundAmount = new anchor.BN(20_000_000); // 20 tokens

      const escrowAta = await anchor.utils.token.associatedAddress({
        mint: paymentMint,
        owner: sessionPda,
      });

      await sessionEscrow.methods
        .fundSession(fundAmount)
        .accounts({
          session: sessionPda,
          escrowTokenAccount: escrowAta,
          userTokenAccount: userTokenAccount,
          user: user1.publicKey,
          tokenProgram: TOKEN_PROGRAM_ID,
        })
        .signers([user1])
        .rpc();

      console.log("✓ Session funded with 20 tokens");
    });
  });

  describe("Protocol Integration", () => {
    it("Full session lifecycle (placeholder)", async () => {
      // This test would cover:
      // 1. Provider acks session (reserves collateral via CPI)
      // 2. Provider redeems permits
      // 3. Session closes (releases collateral via CPI)
      // 
      // For now, just verify programs are accessible
      expect(modeRegistry.programId.toBase58()).to.equal("ModeReg111111111111111111111111111111111111");
      expect(collateralVault.programId.toBase58()).to.equal("CoVau1t111111111111111111111111111111111111");
      expect(sessionEscrow.programId.toBase58()).to.equal("SessEsc111111111111111111111111111111111111");
      expect(stakingRewards.programId.toBase58()).to.equal("StakeRwd11111111111111111111111111111111111");
      console.log("✓ All 4 programs accessible");
    });
  });
});
